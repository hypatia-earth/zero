import { test, expect } from '@playwright/test';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { readCenterPixel, waitForAppReady, waitForLayerReady } from '../helpers';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const FIXTURES_DIR = path.join(__dirname, '../../fixtures');

// Test cases: fixture file, layer, palette, opacity, expected RGB
// .bin files generated by: cd /Users/noiv/Projects/hypatia && source venv/bin/activate && python zero/tests/scripts/generate_test_bins.py
const testCases: Array<{
  fixture: string;
  layer: 'temp' | 'pressure' | 'wind';
  palette: string;
  opacity: number;
  rgb: { r: number; g: number; b: number };
}> = [
  { fixture: 'uniform-55', layer: 'temp', palette: 'Classic Temperature', opacity: 1.0, rgb: { r: 107, g: 28, b: 43 } },
  { fixture: 'uniform-minus20', layer: 'temp', palette: 'Classic Temperature', opacity: 1.0, rgb: { r: 143, g: 168, b: 184 } },
];

/**
 * Load fixture as Float32Array from pre-generated .bin file.
 * Generate with: python zero/tests/scripts/generate_test_bins.py
 */
function loadFixture(name: string): Float32Array {
  const binPath = path.join(FIXTURES_DIR, `${name}.bin`);
  if (!fs.existsSync(binPath)) {
    throw new Error(`Fixture not found: ${binPath}. Run: python zero/tests/scripts/generate_test_bins.py`);
  }
  const buffer = fs.readFileSync(binPath);
  return new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length / 4);
}

test.describe('temp layer deterministic', () => {
  for (const { fixture, layer, palette, opacity, rgb } of testCases) {
    test(`${fixture} @${opacity} → rgb(${rgb.r},${rgb.g},${rgb.b})`, async ({ page }) => {
      // Load pre-generated fixture
      const testData = loadFixture(fixture);

      // Inject test data before navigation
      await page.addInitScript(({ data, layer }) => {
        (window as any).__zeroTestData = {
          [layer]: new Float32Array(data)
        };
      }, { data: Array.from(testData), layer });

      const bootstrapPromise = page.waitForEvent('console', {
        predicate: msg => msg.text().includes('[ZERO] Bootstrap complete'),
        timeout: 60000
      });

      await page.goto(`https://localhost:5173/?layers=${layer}`);
      await bootstrapPromise;

      // Set palette and opacity
      await page.evaluate(({ layer, palette, opacity }) => {
        const h = (window as any).__hypatia;
        h?.paletteService?.setPalette(layer, palette);
        h?.optionsService?.update((d: any) => {
          d[layer].opacity = opacity;
        });
      }, { layer, palette, opacity });

      await page.waitForTimeout(500);

      const pixel = await readCenterPixel(page);
      console.log(`${fixture}:`, pixel);

      // Exact RGB match (allow ±1 for rounding)
      expect(pixel.r).toBeGreaterThanOrEqual(rgb.r - 1);
      expect(pixel.r).toBeLessThanOrEqual(rgb.r + 1);
      expect(pixel.g).toBeGreaterThanOrEqual(rgb.g - 1);
      expect(pixel.g).toBeLessThanOrEqual(rgb.g + 1);
      expect(pixel.b).toBeGreaterThanOrEqual(rgb.b - 1);
      expect(pixel.b).toBeLessThanOrEqual(rgb.b + 1);
    });
  }
});

test.describe('temp.enabled', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await waitForAppReady(page);
  });

  test('toggle on shows temperature layer', async ({ page }) => {
    // Enable temp layer with earth
    await page.evaluate(() => {
      const opts = (window as any).__hypatia.optionsService;
      opts.update((d: any) => {
        d.earth.enabled = true;
        d.temp.enabled = true;
        d.temp.opacity = 1.0;
      });
    });

    // Wait for temp data
    await waitForLayerReady(page, 'temp');
    await page.waitForTimeout(500);

    // Sample center pixel - should show globe content (not background)
    const pixel = await readCenterPixel(page);

    console.log('Temp ON - center pixel:', pixel);

    // Background is (22, 22, 22) - globe content should differ
    const isBackground = pixel.r === 22 && pixel.g === 22 && pixel.b === 22;
    expect(isBackground).toBe(false);
  });

  test('toggle off hides temperature layer', async ({ page }) => {
    // Enable earth + temp
    await page.evaluate(() => {
      const opts = (window as any).__hypatia.optionsService;
      opts.update((d: any) => {
        d.earth.enabled = true;
        d.temp.enabled = true;
        d.temp.opacity = 1.0;
      });
    });
    await waitForLayerReady(page, 'temp');
    await page.waitForTimeout(500);

    // Capture pixel with temp ON
    const pixelOn = await readCenterPixel(page);

    // Disable temp
    await page.evaluate(() => {
      (window as any).__hypatia.optionsService.update((d: any) => {
        d.temp.enabled = false;
      });
    });
    await page.waitForTimeout(500);

    // Capture pixel with temp OFF
    const pixelOff = await readCenterPixel(page);

    console.log('Temp ON:', pixelOn, 'Temp OFF:', pixelOff);

    // Pixels should differ when temp is toggled
    const changed = pixelOn.r !== pixelOff.r || pixelOn.g !== pixelOff.g || pixelOn.b !== pixelOff.b;
    expect(changed).toBe(true);
  });

  test('temp.enabled persists after reload', async ({ page }) => {
    // Enable temp
    await page.evaluate(() => {
      (window as any).__hypatia.optionsService.update((d: any) => {
        d.temp.enabled = true;
      });
    });

    // Verify it's enabled
    const enabledBefore = await page.evaluate(() =>
      (window as any).__hypatia.optionsService.options.value.temp.enabled
    );
    expect(enabledBefore).toBe(true);

    // Reload
    await page.reload();
    await waitForAppReady(page);

    // Verify still enabled
    const enabledAfter = await page.evaluate(() =>
      (window as any).__hypatia.optionsService.options.value.temp.enabled
    );
    expect(enabledAfter).toBe(true);
  });
});

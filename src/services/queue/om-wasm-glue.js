/**
 * Vendored Emscripten glue code for Open-Meteo WASM decoder
 * Source: @openmeteo/file-format-wasm (om_reader_wasm.web.js)
 *
 * This file initializes the WASM module and exports the decoder functions.
 * The WASM binary is loaded separately via the wasmBinary option.
 */

async function OmFileFormat(moduleArg = {}) {
    var moduleRtn; var Module = moduleArg; var ENVIRONMENT_IS_WEB = true; var ENVIRONMENT_IS_WORKER = false; var arguments_ = []; var thisProgram = "./this.program"; var quit_ = (status, toThrow) => { throw toThrow }; var _scriptName = import.meta.url; var scriptDirectory = ""; function locateFile(path) { if (Module["locateFile"]) { return Module["locateFile"](path, scriptDirectory) } return scriptDirectory + path } var readAsync, readBinary; if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { try { scriptDirectory = new URL(".", _scriptName).href } catch { } { readAsync = async url => { var response = await fetch(url, { credentials: "same-origin" }); if (response.ok) { return response.arrayBuffer() } throw new Error(response.status + " : " + response.url) } } } else { } var out = console.log.bind(console); var err = console.error.bind(console); var wasmBinary; var ABORT = false; var EXITSTATUS; var readyPromiseResolve, readyPromiseReject; var wasmMemory; var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; var HEAP64, HEAPU64; var runtimeInitialized = false; function updateMemoryViews() { var b = wasmMemory.buffer; HEAP8 = new Int8Array(b); HEAP16 = new Int16Array(b); Module["HEAPU8"] = HEAPU8 = new Uint8Array(b); HEAPU16 = new Uint16Array(b); HEAP32 = new Int32Array(b); HEAPU32 = new Uint32Array(b); HEAPF32 = new Float32Array(b); HEAPF64 = new Float64Array(b); HEAP64 = new BigInt64Array(b); HEAPU64 = new BigUint64Array(b) } function preRun() { if (Module["preRun"]) { if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]]; while (Module["preRun"].length) { addOnPreRun(Module["preRun"].shift()) } } callRuntimeCallbacks(onPreRuns) } function initRuntime() { runtimeInitialized = true; wasmExports["h"]() } function postRun() { if (Module["postRun"]) { if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]]; while (Module["postRun"].length) { addOnPostRun(Module["postRun"].shift()) } } callRuntimeCallbacks(onPostRuns) } var runDependencies = 0; var dependenciesFulfilled = null; function addRunDependency(id) { runDependencies++; Module["monitorRunDependencies"]?.(runDependencies) } function removeRunDependency(id) { runDependencies--; Module["monitorRunDependencies"]?.(runDependencies); if (runDependencies == 0) { if (dependenciesFulfilled) { var callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } function abort(what) { Module["onAbort"]?.(what); what = "Aborted(" + what + ")"; err(what); ABORT = true; what += ". Build with -sASSERTIONS for more info."; var e = new WebAssembly.RuntimeError(what); readyPromiseReject?.(e); throw e } var wasmBinaryFile; function findWasmBinary() { if (Module["locateFile"]) { return locateFile("om_reader_wasm.web.wasm") } return new URL("om_reader_wasm.web.wasm", import.meta.url).href } function getBinarySync(file) { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } throw "both async and sync fetching of the wasm failed" } async function getWasmBinary(binaryFile) { if (!wasmBinary) { try { var response = await readAsync(binaryFile); return new Uint8Array(response) } catch { } } return getBinarySync(binaryFile) } async function instantiateArrayBuffer(binaryFile, imports) { try { var binary = await getWasmBinary(binaryFile); var instance = await WebAssembly.instantiate(binary, imports); return instance } catch (reason) { err(`failed to asynchronously prepare wasm: ${reason}`); abort(reason) } } async function instantiateAsync(binary, binaryFile, imports) { if (!binary) { try { var response = fetch(binaryFile, { credentials: "same-origin" }); var instantiationResult = await WebAssembly.instantiateStreaming(response, imports); return instantiationResult } catch (reason) { err(`wasm streaming compile failed: ${reason}`); err("falling back to ArrayBuffer instantiation") } } return instantiateArrayBuffer(binaryFile, imports) } function getWasmImports() { return { a: wasmImports } } async function createWasm() { function receiveInstance(instance, module) { wasmExports = instance.exports; wasmMemory = wasmExports["g"]; updateMemoryViews(); assignWasmExports(wasmExports); removeRunDependency("wasm-instantiate"); return wasmExports } addRunDependency("wasm-instantiate"); function receiveInstantiationResult(result) { return receiveInstance(result["instance"]) } var info = getWasmImports(); if (Module["instantiateWasm"]) { return new Promise((resolve, reject) => { Module["instantiateWasm"](info, (mod, inst) => { resolve(receiveInstance(mod, inst)) }) }) } wasmBinaryFile ??= findWasmBinary(); var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info); var exports = receiveInstantiationResult(result); return exports } class ExitStatus { name = "ExitStatus"; constructor(status) { this.message = `Program terminated with exit(${status})`; this.status = status } } var callRuntimeCallbacks = callbacks => { while (callbacks.length > 0) { callbacks.shift()(Module) } }; var onPostRuns = []; var addOnPostRun = cb => onPostRuns.push(cb); var onPreRuns = []; var addOnPreRun = cb => onPreRuns.push(cb); function getValue(ptr, type = "i8") { if (type.endsWith("*")) type = "*"; switch (type) { case "i1": return HEAP8[ptr]; case "i8": return HEAP8[ptr]; case "i16": return HEAP16[ptr >> 1]; case "i32": return HEAP32[ptr >> 2]; case "i64": return HEAP64[ptr >> 3]; case "float": return HEAPF32[ptr >> 2]; case "double": return HEAPF64[ptr >> 3]; case "*": return HEAPU32[ptr >> 2]; default: abort(`invalid type for getValue: ${type}`) } } var noExitRuntime = true; function setValue(ptr, value, type = "i8") { if (type.endsWith("*")) type = "*"; switch (type) { case "i1": HEAP8[ptr] = value; break; case "i8": HEAP8[ptr] = value; break; case "i16": HEAP16[ptr >> 1] = value; break; case "i32": HEAP32[ptr >> 2] = value; break; case "i64": HEAP64[ptr >> 3] = BigInt(value); break; case "float": HEAPF32[ptr >> 2] = value; break; case "double": HEAPF64[ptr >> 3] = value; break; case "*": HEAPU32[ptr >> 2] = value; break; default: abort(`invalid type for setValue: ${type}`) } } var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder : undefined; var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => { var maxIdx = idx + maxBytesToRead; if (ignoreNul) return maxIdx; while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx; return idx }; var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => { var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul); if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) { return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr)) } var str = ""; while (idx < endPtr) { var u0 = heapOrArray[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } var u1 = heapOrArray[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } var u2 = heapOrArray[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } return str }; var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : ""; var ___assert_fail = (condition, filename, line, func) => abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]); var __abort_js = () => abort(""); var runtimeKeepaliveCounter = 0; var __emscripten_runtime_keepalive_clear = () => { noExitRuntime = false; runtimeKeepaliveCounter = 0 }; var timers = {}; var handleException = e => { if (e instanceof ExitStatus || e == "unwind") { return EXITSTATUS } quit_(1, e) }; var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0; var _proc_exit = code => { EXITSTATUS = code; if (!keepRuntimeAlive()) { Module["onExit"]?.(code); ABORT = true } quit_(code, new ExitStatus(code)) }; var exitJS = (status, implicit) => { EXITSTATUS = status; _proc_exit(status) }; var _exit = exitJS; var maybeExit = () => { if (!keepRuntimeAlive()) { try { _exit(EXITSTATUS) } catch (e) { handleException(e) } } }; var callUserCallback = func => { if (ABORT) { return } try { func(); maybeExit() } catch (e) { handleException(e) } }; var _emscripten_get_now = () => performance.now(); var __setitimer_js = (which, timeout_ms) => { if (timers[which]) { clearTimeout(timers[which].id); delete timers[which] } if (!timeout_ms) return 0; var id = setTimeout(() => { delete timers[which]; callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now())) }, timeout_ms); timers[which] = { id, timeout_ms }; return 0 }; var abortOnCannotGrowMemory = requestedSize => { abort("OOM") }; var _emscripten_resize_heap = requestedSize => { var oldSize = HEAPU8.length; requestedSize >>>= 0; abortOnCannotGrowMemory(requestedSize) }; { if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"]; if (Module["print"]) out = Module["print"]; if (Module["printErr"]) err = Module["printErr"]; if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"]; if (Module["arguments"]) arguments_ = Module["arguments"]; if (Module["thisProgram"]) thisProgram = Module["thisProgram"] } Module["setValue"] = setValue; Module["getValue"] = getValue; var _om_decoder_init_data_read, _om_decoder_init, _om_variable_get_dimensions, _om_variable_get_chunks, _om_decoder_init_index_read, _om_decoder_read_buffer_size, _om_decoder_next_index_read, _om_decoder_next_data_read, _om_decoder_decode_chunks, _om_header_size, _om_trailer_size, _om_header_type, _om_trailer_read, _om_variable_init, _om_variable_get_name, _om_variable_get_type, _om_variable_get_compression, _om_variable_get_scale_factor, _om_variable_get_add_offset, _om_variable_get_dimensions_count, _om_variable_get_children_count, _om_variable_get_children, _om_variable_get_scalar, __emscripten_timeout, _malloc, _free; function assignWasmExports(wasmExports) { Module["_om_decoder_init_data_read"] = _om_decoder_init_data_read = wasmExports["i"]; Module["_om_decoder_init"] = _om_decoder_init = wasmExports["j"]; Module["_om_variable_get_dimensions"] = _om_variable_get_dimensions = wasmExports["k"]; Module["_om_variable_get_chunks"] = _om_variable_get_chunks = wasmExports["l"]; Module["_om_decoder_init_index_read"] = _om_decoder_init_index_read = wasmExports["m"]; Module["_om_decoder_read_buffer_size"] = _om_decoder_read_buffer_size = wasmExports["n"]; Module["_om_decoder_next_index_read"] = _om_decoder_next_index_read = wasmExports["o"]; Module["_om_decoder_next_data_read"] = _om_decoder_next_data_read = wasmExports["p"]; Module["_om_decoder_decode_chunks"] = _om_decoder_decode_chunks = wasmExports["q"]; Module["_om_header_size"] = _om_header_size = wasmExports["r"]; Module["_om_trailer_size"] = _om_trailer_size = wasmExports["s"]; Module["_om_header_type"] = _om_header_type = wasmExports["t"]; Module["_om_trailer_read"] = _om_trailer_read = wasmExports["u"]; Module["_om_variable_init"] = _om_variable_init = wasmExports["v"]; Module["_om_variable_get_name"] = _om_variable_get_name = wasmExports["w"]; Module["_om_variable_get_type"] = _om_variable_get_type = wasmExports["x"]; Module["_om_variable_get_compression"] = _om_variable_get_compression = wasmExports["y"]; Module["_om_variable_get_scale_factor"] = _om_variable_get_scale_factor = wasmExports["z"]; Module["_om_variable_get_add_offset"] = _om_variable_get_add_offset = wasmExports["A"]; Module["_om_variable_get_dimensions_count"] = _om_variable_get_dimensions_count = wasmExports["B"]; Module["_om_variable_get_children_count"] = _om_variable_get_children_count = wasmExports["C"]; Module["_om_variable_get_children"] = _om_variable_get_children = wasmExports["D"]; Module["_om_variable_get_scalar"] = _om_variable_get_scalar = wasmExports["E"]; __emscripten_timeout = wasmExports["F"]; Module["_malloc"] = _malloc = wasmExports["G"]; Module["_free"] = _free = wasmExports["H"] } var wasmImports = { a: ___assert_fail, d: __abort_js, c: __emscripten_runtime_keepalive_clear, e: __setitimer_js, f: _emscripten_resize_heap, b: _proc_exit }; var wasmExports = await createWasm(); function run() { if (runDependencies > 0) { dependenciesFulfilled = run; return } preRun(); if (runDependencies > 0) { dependenciesFulfilled = run; return } function doRun() { Module["calledRun"] = true; if (ABORT) return; initRuntime(); readyPromiseResolve?.(Module); Module["onRuntimeInitialized"]?.(); postRun() } if (Module["setStatus"]) { Module["setStatus"]("Running..."); setTimeout(() => { setTimeout(() => Module["setStatus"](""), 1); doRun() }, 1) } else { doRun() } } function preInit() { if (Module["preInit"]) { if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]]; while (Module["preInit"].length > 0) { Module["preInit"].shift()() } } } preInit(); run(); if (runtimeInitialized) { moduleRtn = Module } else { moduleRtn = new Promise((resolve, reject) => { readyPromiseResolve = resolve; readyPromiseReject = reject }) }
    ; return moduleRtn
}

export default OmFileFormat;

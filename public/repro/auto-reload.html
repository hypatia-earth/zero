<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chrome WebGPU Reload Crash Repro</title>
  <style>
    body { margin: 0; background: #1a1a2e; color: #fff; font-family: system-ui; padding: 20px; }
    iframe { width: 100%; height: 75vh; border: 2px solid #333; }
    #log { font-family: monospace; font-size: 14px; margin-top: 10px; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
    .crash { color: #f44; }
    .ok { color: #4f4; }
    button { padding: 8px 16px; font-size: 14px; margin-right: 10px; cursor: pointer; }
  </style>
</head>
<body>
  <h3>Chrome WebGPU Reload Crash Repro - <a href="https://issues.chromium.org/issues/469455157" style="color:#4fc3f7">Bug 469455157</a></h3>
  <div>
    <button onclick="stop()">Stop</button>
    <button onclick="location.reload()">Restart</button>
    <span id="status" style="margin-left:20px"></span>
  </div>
  <div id="log"></div>
  <iframe id="frame" src="about:blank"></iframe>

  <script>
    const frame = document.getElementById('frame');
    const log = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const TARGET = '/';  // Same origin - loads Zero
    const WAIT_FOR_RENDER = 10000;
    const BETWEEN_RELOADS = 2000;
    const MAX_RELOADS = 5;

    let reloadCount = 0;
    let running = true;
    let timeout = null;

    function addLog(msg, type) {
      const time = new Date().toLocaleTimeString();
      const cls = type === 'crash' ? 'crash' : type === 'ok' ? 'ok' : '';
      log.innerHTML += `<span class="${cls}">[${time}] ${msg}</span>\n`;
      log.scrollTop = log.scrollHeight;
    }

    function updateStatus(msg) {
      statusEl.textContent = msg;
    }

    function checkForCrash() {
      try {
        const doc = frame.contentDocument;
        if (!doc) return 'unknown';
        const text = doc.body?.innerText || '';
        if (text.includes('No adapter') || text.includes('Failed at') || text.includes('Error')) {
          return 'crash';
        }
        // Check if canvas is rendering (has WebGPU context)
        const canvas = doc.querySelector('canvas');
        if (canvas) {
          return 'ok';
        }
        return 'loading';
      } catch (e) {
        return 'unknown';
      }
    }

    async function doReload() {
      if (!running) return;

      reloadCount++;
      updateStatus(`Reload ${reloadCount}/${MAX_RELOADS} - Loading...`);
      addLog(`Reload #${reloadCount}: Loading Zero...`);

      frame.src = TARGET + '?repro=' + reloadCount + '&t=' + Date.now();

      await new Promise(resolve => {
        const onLoad = () => {
          frame.removeEventListener('load', onLoad);
          resolve();
        };
        frame.addEventListener('load', onLoad);
        setTimeout(resolve, 15000);
      });

      updateStatus(`Reload ${reloadCount}/${MAX_RELOADS} - Waiting for render...`);
      addLog(`Reload #${reloadCount}: Waiting ${WAIT_FOR_RENDER/1000}s for render...`);
      await new Promise(r => setTimeout(r, WAIT_FOR_RENDER));

      const status = checkForCrash();
      if (status === 'crash') {
        addLog(`Reload #${reloadCount}: CRASH DETECTED`, 'crash');
        updateStatus(`CRASH at reload ${reloadCount}!`);
      } else {
        addLog(`Reload #${reloadCount}: OK`, 'ok');
      }

      if (reloadCount < MAX_RELOADS && running) {
        updateStatus(`Reload ${reloadCount}/${MAX_RELOADS} - Next in ${BETWEEN_RELOADS/1000}s...`);
        timeout = setTimeout(doReload, BETWEEN_RELOADS);
      } else if (running) {
        addLog(`\nTest complete. Check chrome://gpu for GPU status.`);
        updateStatus(`Done - ${reloadCount} reloads`);
        running = false;
      }
    }

    function stop() {
      running = false;
      if (timeout) clearTimeout(timeout);
      addLog('Stopped.');
      updateStatus('Stopped');
    }

    // Auto-start
    addLog('Chrome WebGPU Reload Crash Repro');
    addLog('Target: Zero (same origin)');
    addLog(`Wait: ${WAIT_FOR_RENDER/1000}s per reload, ${MAX_RELOADS} reloads\n`);
    doReload();
  </script>
</body>
</html>
